import json
import os
import sys
import shutil
import msgpack
import maya
import traceback
from timeit import default_timer as timer

from nucypher.characters.lawful import Bob, Ursula
from nucypher.crypto.kits import UmbralMessageKit
from nucypher.crypto.powers import DecryptingPower, SigningPower
from nucypher.data_sources import DataSource
from nucypher.keystore.keypairs import DecryptingKeypair, SigningKeypair
from nucypher.network.middleware import RestMiddleware

from umbral.keys import UmbralPublicKey

import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

######################
# Boring setup stuff #
######################

SEEDNODE_URL = '146.169.207.43:11501'

# TODO: path joins?
TEMP_CHARLIE_DIR = "{}/charlie-files".format(os.path.dirname(os.path.abspath(__file__)))



#Created this function to be able to attach this to the client side


# Remove previous demo files and create new ones

def generate_charlie():
    shutil.rmtree(TEMP_CHARLIE_DIR, ignore_errors=True)

    ursula = Ursula.from_seed_and_stake_info(seed_uri=SEEDNODE_URL,
                                             federated_only=True,
                                             minimum_stake=0)

    # To create a Bob, we need the charlie's private keys previously generated.
    from charlie_keys import get_charlie_privkeys
    charlie_keys = get_charlie_privkeys()

    bob_enc_keypair = DecryptingKeypair(private_key=charlie_keys["enc"])
    bob_sig_keypair = SigningKeypair(private_key=charlie_keys["sig"])
    enc_power = DecryptingPower(keypair=bob_enc_keypair)
    sig_power = SigningPower(keypair=bob_sig_keypair)
    power_ups = [enc_power, sig_power]

    print("Creating the Charlie ...")

    charlie = Bob(
        is_me=True,
        federated_only=True,
        crypto_power_ups=power_ups,
        start_learning_now=True,
        abort_on_learning_error=True,
        known_nodes=[ursula],
        save_metadata=False,
        network_middleware=RestMiddleware(),
    )

    print("Charlie = ", charlie)

    # Let's join the policy generated by Alicia. We just need some info about it.
    with open("policy-metadata.json", 'r') as f:
        policy_data = json.load(f)

    policy_pubkey = UmbralPublicKey.from_bytes(bytes.fromhex(policy_data["policy_pubkey"]))
    arjuns_sig_pubkey = UmbralPublicKey.from_bytes(bytes.fromhex(policy_data["arjun_sig_pubkey"]))
    label = policy_data["label"].encode()

    print("The Charlie joins policy for label '{}'".format(label.decode("utf-8")))
    charlie.join_policy(label, arjuns_sig_pubkey)

    return charlie, policy_pubkey, arjuns_sig_pubkey, label

# Now that the Doctor joined the policy in the NuCypher network,
# he can retrieve encrypted data which he can decrypt with his private key.
# But first we need some encrypted data!

    #We need to upgrade this so that we can send any message instead of packing a messages and getting the message again üòçüòçüòçüòç

# Let's read the file produced by the heart monitor and unpack the MessageKits,
# which are the individual ciphertexts.

# here we start decrypting the message

def decrypting_msg(data, policy_pubkey, label, arjuns_sig_pubkey, charlie):
    data = msgpack.loads(data, raw=False)
    print("afterjson", data)
    message_kits = (UmbralMessageKit.from_bytes(k) for k in data['kits'])

    # The charlie also needs to create a view of the Data Source from its public keys
    data_source = DataSource.from_public_keys(
            policy_public_key=policy_pubkey,
            datasource_public_key=data['data_source'],
            label=label
    )

    # Now he can ask the NuCypher network to get a re-encrypted version of each MessageKit.
    for message_kit in message_kits:
        try:
            start = timer()
            retrieved_plaintexts = charlie.retrieve(
                message_kit=message_kit,
                data_source=data_source,
                alice_verifying_key=arjuns_sig_pubkey
            )
            end = timer()

            plaintext = msgpack.loads(retrieved_plaintexts[0], raw=False)

            # Now we can get the heart rate and the associated timestamp,
            # generated by the heart rate monitor.
            msg = plaintext['msg']
            timestamp = maya.MayaDT(plaintext['timestamp'])

            # # This code block simply pretty prints the heart rate info
            # terminal_size = shutil.get_terminal_size().columns
            # max_width = min(terminal_size, 120)
            # columns = max_width - 12 - 27
            # scale = columns/40
            # scaled_heart_rate = int(scale * (heart_rate - 60))
            # retrieval_time = "Retrieval time: {:8.2f} ms".format(1000*(end - start))
            # line = ("-" * scaled_heart_rate) + "‚ù§Ô∏é ({} BPM)".format(heart_rate)
            # line = line.ljust(max_width - 27, " ") + retrieval_time
            return msg
        except Exception as e:
            # We just want to know what went wrong and continue the demo
            traceback.print_exc()

